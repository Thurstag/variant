<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ include file="Functions.ttinclude" #>
<#@ parameter type="System.Int32" name="VariantArgumentTypesCount" #>
// Copyright 20222-<#= DateTime.Now.Year #> variant Project
// Licensed under Apache License 2.0 or any later version
// Refer to the LICENSE file included.

namespace System;

<#
            for (var variant = 0; variant < VariantArgumentTypesCount; variant++) {
                var variantTypeParameters = Enumerable.Range(0, variant + 1).Select(VariantTypeParameter).ToArray();
                var variantType = VariantType(variantTypeParameters);
#>
/// <summary>
/// A type-safe union containing one of its type arguments at a time
/// </summary>
<#
                foreach (var variantTypeParameter in variantTypeParameters) {
#>
/// <typeparam name="<#= variantTypeParameter #>">Possible value type</typeparam>
<#
                }
#>
/// <remarks>This class was generated by T4 tool</remarks>
public abstract class <#= variantType #> {

    /// <summary>
    /// Create an instance of <#= SeeVariantType(variantTypeParameters) #>
    /// </summary>
    private Variant() {
        // Disable public inheritance
    }

<#
                var mapArguments = string.Join(", ", variantTypeParameters.Select(t => $"Func<{t}, T> map{t.ToUpper()}"));
#>
    /// <summary>
    /// Map the value held by this variant using the suitable function
    /// </summary>
<#
                foreach (var variantTypeParameter in variantTypeParameters) {
#>
    /// <param name="map<#= variantTypeParameter #>">Function taking a <see cref="<#= variantTypeParameter #>"/> and returning a <see cref="T"/> </param>
<#
                }
#>
    /// <typeparam name="T">Result type</typeparam>
    /// <returns>Mapping result</returns>
    public abstract T Map<T>(<#= mapArguments #>);
<#
                // Implicit operators
                for (var @operator = 0; @operator <= variant; @operator++) {
                    var argName = $"t{@operator}";
                    var argType = variantTypeParameters[@operator];
#>

    /// <summary>
    /// Convert a <see cref="<#= argType #>"/> into a <#= SeeVariantType(variantTypeParameters) #>
    /// </summary>
    /// <param name="<#= argName #>">Conversion input</param>
    /// <returns>Variant</returns>
    public static implicit operator <#= variantType #>(<#= argType #> <#= argName #>) => new <#= VariantImplType(@operator) #>(<#= argName #>);
<#
                }
                if (variantTypeParameters.Length > 1) {
                    foreach (var variantSubsetTypeParameters in SubLists(variantTypeParameters).Select(a => a.ToArray())) {
#>

    /// <summary>
    /// Convert a <#= SeeVariantType(variantSubsetTypeParameters) #> into a <#= SeeVariantType(variantTypeParameters) #>
    /// </summary>
    /// <param name="variant">Conversion input</param>
    /// <returns>Variant</returns>
    public static implicit operator <#= variantType #>(<#= VariantType(variantSubsetTypeParameters) #> variant) => variant.Map<<#= variantType #>>(<#=
                            string.Join(", ", variantSubsetTypeParameters.Select(_ => "t => t")) #>);
<#
                    }
                }
#>
<#
                // Implementations
                for (var impl = 0; impl <= variant; impl++) {
                    var variantTypeParameter = variantTypeParameters[impl];
                    var implName = VariantImplType(impl);
                    var propertyName = $"_t{impl}";
                    var constArgName = $"t{impl}";
#>

    /// <summary>
    /// Implementation of <#= SeeVariantType(variantTypeParameters) #> holding a <see cref="<#= variantTypeParameter #>"/>
    /// </summary>
    private class <#= implName #> : <#= variantType #> {
        private readonly <#= variantTypeParameter #> <#= propertyName #>;

        /// <summary>
        /// Create an instance of <see cref="Variant{<#= string.Join(", ", variantTypeParameters) #>}.<#= implName #>"/> with the given value
        /// </summary>
        /// <param name="<#= constArgName #>">Value</param>
        public <#= implName #>(<#= variantTypeParameter #> <#= constArgName #>) => <#= propertyName #> = <#= constArgName #>;

        public override T Map<T>(<#= mapArguments #>) => map<#= variantTypeParameter #>(<#= propertyName #>);
    }
<#
                }
#>
}

<#
            }
#>